import numpy as np
import random

import pandas as pd
from scipy.sparse import csr_matrix
from scipy.sparse import vstack

import cPickle as pickle

import os 
dir_path = os.path.dirname(os.path.realpath(__file__))

processed_dir = dir_path+'/../../data/processed/'

with open(processed_dir+"x_manifest.pickle", "rb") as f:
    x_manifest = pickle.load( f )

with open(processed_dir+"x_manifest_mal.pickle", "rb") as f:
    x_manifest_mal = pickle.load( f )

with open(processed_dir+"x_code.pickle", "rb") as f:
    x_code = pickle.load( f )

with open(processed_dir+"x_code_mal.pickle", "rb") as f:
    x_code_mal = pickle.load( f )

with open(processed_dir+"x_test.pickle", "rb") as f:
    x_test = pickle.load( f )

with open(processed_dir+"y_test.pickle", "rb") as f:
    y_test = pickle.load( f )

#Load hash orders
with open( processed_dir+"good_hashes.pickle", "rb" ) as f:
    good_hashes = pickle.load( f )

with open( processed_dir+"mal_hashes.pickle", "rb" ) as f:
    mal_hashes = pickle.load( f )

train_good = x_manifest.shape[0]
train_mal = x_manifest_mal.shape[0]

valid_good = int(train_good/10)
valid_mal = int(train_mal/10)

train_good = train_good - valid_good
train_mal = train_mal - valid_mal

def roll(a, start, end):
    if start < end:
        return a[start:end]
    else:
        return np.append(a[start:], a[:end])

def train_gen(batch_size=1000, mwr=0.3, distil_temp=1.0, ret_hashes=False):
    
    if distil_temp != 1.0:
        with open( processed_dir+"distil/y_good_distill.mwr-{}.temp-{}.pickle".format(mwr, distil_temp), "rb" ) as f:
            y_good_distill = pickle.load( f )

        with open( processed_dir+"distil/y_mal_distill.mwr-{}.temp-{}.pickle".format(mwr, distil_temp), "rb" ) as f:
            y_mal_distill = pickle.load( f )

    while True:
        perm_good = np.random.permutation(train_good)
        perm_mal = np.random.permutation(train_mal)
        
        y = np.zeros((batch_size,), dtype=np.int8)
        
        mal_batch = int(batch_size * mwr)

        i = 0
        j = 0
        while i < train_mal:
            if train_mal - i < mal_batch:
                mal_batch = train_mal - i
            good_batch = int((mal_batch / mwr) * (1-mwr))
            
            full_batch = mal_batch + good_batch
            
            if full_batch != batch_size:
                y = np.zeros((full_batch,), dtype=np.int8)
            
            good_idx = roll(perm_good, j, (j+good_batch) % train_good)
            mal_idx = perm_mal[i:i+mal_batch]

            x_m = vstack([x_manifest[good_idx], x_manifest_mal[mal_idx]])
            x_c = vstack([x_code[good_idx], x_code_mal[mal_idx]])
            
            if distil_temp != 1.0:
                y[:good_batch] = y_good_distill[good_idx]
                y[good_batch:] = y_mal_distill[mal_idx]
            else:
                y[:good_batch] = 0
                y[good_batch:] = 1

            if ret_hashes:
                hashes = []
                for idx in good_idx:
                    hashes.append(good_hashes[idx])
                for idx in mal_idx:
                    hashes.append(mal_hashes[idx])

                yield ([x_m, x_c], y, hashes)
            else:
                yield ([x_m, x_c], y)
            
            i = i + mal_batch
            j = (j + good_batch) % train_good